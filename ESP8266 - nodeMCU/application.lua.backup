log = "" -- Keep a log in memory with a fixed size
maxLogLength = 5000 -- 5kb
currentStatus = "Not yet set"
currentPosition = "Not yet set"
currentWaterLevelKg = "Not yet set kg"
currentWaterLevelPercent = "Not set set %";

chunkedResponse = nil
chunkToSend = 0

print("Start web server")
srv=net.createServer(net.TCP)
srv:listen(80,function(conn)
    conn:on("receive",function(conn,payload)
		local request = createRequest(payload)
		local cmd = ""
		local repliedAlready = false
		
		local html = ""		
		
		if request ~= null then
			cmd = string.sub(request.path, 2, string.len(request.path))
            if(cmd ~= "favicon.ico") then

                html = html .. "<html><body>"
				html = html .. "<div class=\"col-sm-12\"><h1>Chicken Shed</h1>"
				html = html .. "Status: " .. currentStatus
				html = html .. "<br />Door: " .. currentPosition .. "<br />Water:" .. currentWaterLevelKg .. "<br /><br />"
				html = html .. "<div class=\"card-title\">Actions:</div>"
				html = html .. "<a href=\"/OpenDoor\">Open Door</a><br><a href=\"/CloseDoor\">Close Door</a><br><a href=\"/GetStatus\">Refresh Status</a><br>"
				html = html .. "[AdditionalHtml]"
				html = html .. "</body></html>"
            
				---- Split the response into an array of strings by line and send it line by line, as sending it all at once can result in out of memory exception
    			--print("Get html as an array of lines")
				--chunkedResponse = lines(html)
				--print("lines: " .. (#chunkedResponse))
				--chunkToSend = 0
				
    			if string.len(request.path) > 1 then
    				if string.find(request.path, "/GetStatus") ~= nil then
    					repliedAlready = true
						--print("Start sending")
    					--conn:send("<html>")		
    				else
    					print(cmd) -- Send command to Arduino
    				end
    				if repliedAlready == false then
    					html = string.gsub(html, "[AdditionalHtml]", "<br /><div style=\"color:green;\">Command sent to arduino: " .. cmd .. "</div><br />")
    				end
    			end
    			if string.len(request.path) < 1 then
    				html = string.gsub(html, "[AdditionalHtml]", "<br /><div style=\"color:red;\">No command provided</div><br />")
    			end
				-- Replace any unreplaced tokens and send the html
				html = string.gsub(html, "[AdditionalHtml]", "")
				conn:send(html)
				conn:close()
			else
				conn:close()
		    end
		end
		--if request == nil then
		--	html = string.gsub(html, "{AdditionalHtml}", "<br /><div class=\"glyphicon glyphicon-remove\" style=\"color:red;\">&nbsp;</div>No command provided.")
		--end
		
		request = nil
		cmd = nil
		repliedAlready = nil
		html = nil
		collectgarbage()
	end)
	conn:on("sent",function(conn)
		print("sent called")
		conn:close()		
		
		---- Data is sent line by line because of memory. This method is used to send subsequent lines until the full response is done.
		--if(chunkedResponse ~= nil and (#chunkedResponse) > -1 and (#chunkedResponse) >= chunkToSend) then
		--	print("Send chunk index " .. chunkToSend)
		--	conn:send(chunkedResponse[chunkToSend])
		--	chunkToSend = chunkToSend + 1
		--else
		--	-- Finished
		--	conn:close()
		--	print("Finished sending")
		--	chunkToSend = -1
		--	chunkedResponse = nil
		--	--collectgarbage()
		--end
	end)
end)

-- Request the latest variables from Arduino (status and position) when the chip loads. Wait 10 seconds, to ensure Arduino loads first.
tmr.alarm(1, 10000, 0, function()
	print("SendCurrentVariablesToWifi");
end)

function lines(str)
  local t = {}
  local function helper(line) table.insert(t, line) return "" end
  helper((str:gsub("(.-)\r?\n", helper)))
  return t
end

-- Arduino may call this function to append to the log
function logMessage(msg)
	log = log .. msg .. "\r\n"
	if(string.len(log) > maxLogLength) then
		log = string.sub(str1, string.len(str1)-1000, string.len(str1))
	end
end
-- Arduino reports back on the water level
function updateVariables(strStatus, strPosition, strWaterLevelKg, strWaterLevelPercent)
	currentStatus = strStatus
	currentPosition = strPosition
	currentWaterLevelKg = strWaterLevelKg
	currentWaterLevelPercent = strWaterLevelPercent
end

function elSplit( value, inSplitPattern, outResults )
   if not outResults then
      outResults = { }
   end
   local theStart = 1
   local theSplitStart, theSplitEnd = string.find( value, inSplitPattern, theStart )
   while theSplitStart do
      table.insert( outResults, string.sub( value, theStart, theSplitStart-1 ) )
      theStart = theSplitEnd + 1
      theSplitStart, theSplitEnd = string.find( value, inSplitPattern, theStart )
   end
   table.insert( outResults, string.sub( value, theStart ) )
   return outResults
end

function isempty(s)
  return s == nil or s == ''
end

function createRequest(payload)
    local request = {}
    
    local splitPayload = elSplit(payload, "\r\n\r\n")
    local httpRequest = elSplit((splitPayload[1]), "\r\n")
    if not isempty((splitPayload[2])) then 
        request.content = json.decode((splitPayload[2]))
    end
    
    local splitUp = elSplit((httpRequest[1]), "%s+")
    
    request.method = (splitUp[1])
    request.path = (splitUp[2])
    request.protocal = (splitUp[3])

    local pathParts = elSplit(request.path, "/")
    local maybeId = tonumber((pathParts[table.getn(pathParts)]))

    if maybeId ~= nil then 
        request.fullPath = request.url
        request.path = string.sub(request.fullPath, 1, string.len(request.fullPath) - string.len("" .. maybeId))
        request.id = maybeId
    end
    
    --print(node.heap())
    httpRequest = nil
    splitUp = nil
    splitPayload = nil
    maybeId = nil
    collectgarbage()
    --print(node.heap())
    return request
end
